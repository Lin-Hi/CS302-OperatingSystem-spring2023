### fork()复制PCB时，两个策略的对比

在内核视角下，fork()系统调用会创建一个新进程，这个新进程是原始进程（父进程）的一个副本。在创建新进程时，内核需要将父进程的地址空间复制到子进程。有两种主要的复制策略：Duplicate Address Space（完全复制）和 Copy on Write（写时复制）。

1. Duplicate Address Space（完全复制）： 这种策略是将整个父进程的地址空间完全复制到子进程中。这意味着所有数据、堆、栈和代码都会在子进程中生成新的副本。这种方法的缺点是需要大量的内存和时间。因为在复制过程中，内核需要为子进程分配与父进程相同大小的内存空间，并将父进程的整个地址空间内容复制到新分配的内存中。如果父进程的地址空间很大，这将导致内存使用率和复制时间的浪费。
2. Copy on Write（写时复制）： 这种策略的基本思想是只在需要时复制父进程的内存区域。在fork()时，子进程的地址空间不是完全复制，而是与父进程共享相同的内存区域。所有的共享内存区域都被标记为“只读”。当父进程或子进程尝试修改共享内存区域时，内核会捕捉到这个操作，此时才会为修改的内存区域创建新的副本，实现真正意义上的复制。这种策略大大减少了fork()操作所需的内存和时间开销，因为只有在实际需要时才进行内存复制。

总之，Duplicate Address Space和Copy on Write都是fork()系统调用在复制父进程地址空间时采用的策略。Duplicate Address Space会在fork()时复制整个地址空间，而Copy on Write则会延迟复制，直到实际需要修改内存时才进行。Copy on Write策略更加高效，因为它减少了不必要的内存分配和复制操作。

### 打开文件列表

在使用fork()系统调用创建新进程时，子进程会继承父进程的一些资源，包括打开的文件描述符。这意味着子进程可以访问父进程打开的文件，也会共享相同的文件偏移量和文件状态标志等信息。

打开的文件描述符通常存储在一个数组中，以下是数组中的一些常见索引及其描述：

| Array Index | Description                                               |
| ----------- | --------------------------------------------------------- |
| 0           | Standard Input Stream; FILE *stdin;                       |
| 1           | Standard Output Stream; FILE *stdout;                     |
| 2           | Standard Error Stream; FILE *stderr;                      |
| 3 or beyond | Storing the files you opened, e.g., fopen(), open(), etc. |

这就是为什么父进程和子进程会共享相同的终端输入/输出流。它们都使用相同的文件描述符数组，因此stdin（标准输入）、stdout（标准输出）和stderr（标准错误）都指向相同的文件/设备。这使得父子进程可以共享同一个终端进行输入和输出。

然而，在某些情况下，这种共享可能导致问题，比如当父子进程同时向stdout写入时，可能会导致输出混乱。为避免这种情况，可以在fork()之后使用适当的同步机制，如信号量或互斥锁，确保父子进程在访问共享资源时不发生冲突。

#### Real time 与 user time + system time

实际情况下，real time（实际时间）通常大于 user time（用户时间）加上 system time（系统时间）。这是因为程序在执行过程中可能会遇到多种等待情况，例如：

1. 等待I/O操作完成（如读写文件、网络通信等）。
2. 等待其他进程释放共享资源。
3. 等待操作系统调度，因为操作系统可能会在多个进程之间切换。
4. 页面缺失（page faults）和其他内存管理相关的延迟。

这些等待时间不属于用户时间或系统时间的范畴，但会导致实际时间增加。因此，通常情况下，real time > user time + system time。

然而，在某些特殊情况下，real time 可能小于 user time 加上 system time。这通常发生在多核处理器系统上，其中多个线程或进程可以并行执行。在这种情况下，用户时间和系统时间是累积计算的，因此可以在多个核心上并行执行的部分会被计算多次。实际时间仍然是程序开始到结束所经历的时间，但由于并行执行，这段时间可能小于所有线程或进程的用户时间和系统时间之和。

#### user-level 和 kernel-level thread

user-level thread（用户级线程）和 kernel-level thread（内核级线程）是两种不同级别的线程实现方式。

1. 用户级线程（user-level thread）： 用户级线程由程序或应用在用户空间实现和管理，操作系统内核对其不可见。线程的创建、调度和管理完全由用户空间的线程库（如 POSIX pthreads）完成，操作系统不直接参与。用户级线程的优点是轻量级、创建和切换速度快，以及可以在不支持线程的操作系统上实现。然而，缺点是一个用户级线程阻塞（例如等待 I/O 完成）时，整个进程（包括所有用户级线程）也会阻塞；此外，用户级线程不能利用多核处理器并行执行。
2. 内核级线程（kernel-level thread）： 内核级线程由操作系统内核实现和管理。内核维护所有线程的状态和调度信息，这使得内核能够独立调度每个线程。内核级线程的优点是可以在多核处理器上实现并行执行，以及单个线程的阻塞不会影响同一进程中的其他线程。然而，缺点是创建、销毁和切换线程时需要进行系统调用，这会带来更高的开销。

用户级线程和内核级线程之间的关系在于，用户级线程可以映射到一个或多个内核级线程。这种映射关系取决于线程库和操作系统如何实现。例如，有以下几种映射方式：

1. 一对一映射：每个用户级线程映射到一个内核级线程。这种方式可以充分利用多核处理器，但由于系统调用的开销，线程管理的性能较低。
2. 多对一映射：多个用户级线程映射到一个内核级线程。这种方式的优点是线程管理开销较低，但缺点是无法利用多核处理器，且一个用户级线程的阻塞会影响整个进程。
3. 多对多映射：多个用户级线程映射到多个内核级线程。这种方式可以平衡用户级线程和内核级线程之间的优缺点，提供更好的并行性和灵活性